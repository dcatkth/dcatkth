---
layout: page
title: Systems
permalink: /systems/
---
<center><img src="/images/research.jpg" width="1000" height="200" align="center"></center>

<br>
<a href="http://www.hops.io/"><img src="/images/projects/hops.png" width="8%" height="8%"/></a><br>
<p align="justify">Hops is a next-generation distribution of Apache Hadoop, with a heavily adapted impelementation of HDFS, called HopsFS. HopsFS is a new implementation of the the Hadoop Filesystem (HDFS) based on Apache Hadoop 2.8, that supports multiple stateless NameNodes, where the metadata is stored in an in-memory distributed database (NDB). HopsFS enables NameNode metadata to be both customized and analyzed, because it can be easily accessed via SQL or the native API (NDB API). Read more <a href="http://www.hops.io/">here</a>.</p>

<br><br>

<a href="https://flink.apache.org/"><img src="/images/projects/flink.jpg" alt="Flink" width="10%" height="10%"></a><br>
<p align="justify">Apache Flink is a platform for efficient, distributed, general-purpose data processing. It features powerful programming abstractions in Java and Scala, a high-performance runtime, and automatic program optimization. It has native support for iterations, incremental iterations, and programs consisting of large DAGs of operations. Flink Streaming is an extension of the core Flink API for high-throughput, low-latency data stream processing. The system can connect to and process data streams from many data sources like RabbitMQ, Flume, Twitter, ZeroMQ and also from any user defined data source. Read more <a href="https://flink.apache.org/">here</a>.</p>

<br><br>

<a href="http://www.gecode.org/"><img src="/images/projects/gecode.png" alt="Gecode" width="10%" height="10%"></a><br>
<p align="justify">Gecode is an open, free, portable, accessible, and efficient environment for developing constraint-based systems and applications in research, industry, and education.
Particularly important for its design is simplicity and accessibility. Simplicity is the key reason why Gecode is efficient and successfully exploits today's commodity parallel hardware. Accessibility is due to its complete reference documentation, complete tutorial documentation, and academic publications in conferences and journals presenting key design decisions and techniques.
Gecode is widely used (several thousand users): as a research vehicle; for teaching constraint programming at several universities around the world; as an application platform by companies; it is included in distributions such as Debian, Ubuntu, OpenSUSE, Gentoo, and FreeBSD (and possibly others). Read more <a href="http://www.gecode.org">here</a>.</p>

<br><br>

<a href="http://www.karamel.io/"><img src="/images/projects/karamel.png" alt="Karamel" width="15%" height="15%"></a><br>
<p align="justify">Karamel is an orchestration engine for Chef Solo that enables the deployment of arbitrarily large distributed systems on both virtualized platforms, e.g., AWS, and bare-metal hosts. A distributed system is defined in YAML as a set of node groups that each implement a number of Chef recipes, where the Chef cookbooks are deployed on github. Karamel orchestrates the execution of Chef recipes using a set of ordering rules defined in a YAML file (Karamelfile) in each cookbook. For each recipe, the Karamelfile can define a set of dependent (possibly external) recipes that should be executed before it. At the system level, the set of Karamelfiles defines a directed acyclic graph (DAG) of service dependencies. Karamel system definitions are very compact. We leverage Berkshelf to transparently download and install transitive cookbook dependencies, so large systems can be defined in a few lines of code. Finally, the Karamel runtime builds and manages the execution of the DAG of Chef recipes, by first launching the virtual machines or configuring the bare-metal boxes and then executing recipes with Chef Solo. The Karamel runtime executes the node setup steps using JClouds or ssh. Karamel transparently handles faults by retrying, as virtual machine creation or configuration is not always reliable or timely. Read more <a href="http://www.karamel.io/">here</a>.</p>

<br><br>

<a href="http://kompics.github.io/docs/current/"><img src="/images/projects/kompics.png" alt="Kompics" width="18%" height="18%"></a><br>
<p align="justify">Kompics is a message-passing component model for building distributed systems by putting together protocols programmed as event-driven components. Systems built with Kompics leverage multi-core machines out of the box and can be dynamically reconfigured to support hot software upgrades. A simulation framework enables deterministic debugging and reproducible performance evaluation of unmodified Kompics distributed systems. Read more <a href="http://kompics.github.io/docs/current/">here</a>.</p>

<br><br>

<a href="https://unison-code.github.io/"><img src="/images/projects/unison.png" alt="Unison" width="18%" height="18%"></a><br>
<p align="justify">Unison is a simple, flexible, and potentially optimal tool that performs integrated register allocation and instruction scheduling using constraint programming as a modern method for combinatorial optimization.

Unison is a collaboration between KTH, RISE SICS, and Ericsson. Its design and development has been partially funded by KTH, Ericsson AB, and the Swedish Research Council. Read more <a href="https://unison-code.github.io/">here</a>.</p>

<br><br>

<a href="http://cats.sics.se/"><img src="/images/projects/cats.png" alt="CATS" width="12%" height="12%"></a><br>
<p align="justify">Distributed key-value stores provide scalable, fault-tolerant, and self-organizing storage services, but fall short of guaranteeing linearizable consistency in partially synchronous, lossy, partitionable, and dynamic networks, when data is distributed and replicated automatically by the principle of consistent hashing. CATS is a distributed key-value store that uses consistent quorums to guarantee linearizability and partition tolerance in such adverse and dynamic network conditions. CATS is scalable, elastic, and self-organizing; key properties for modern cloud storage middleware. Read more <a href="http://cats.sics.se/">here</a>.</p>

<br><br>

<a href="https://github.com/alshishtawy/ElastMan"><img src="/images/projects/elastman.png" alt="ElastMan" width="15%" height="15%"></a><br>
<p align="justify">ElastMan is an elasticity controller for Elastic Cloud-based services. ElastMan combines feedforward and feedback control. Feedforward control is used to respond to spikes in the workload by quickly resizing the service to meet SLOs at a minimal cost. Feedback control is used to correct modeling errors and to handle diurnal workload. To address nonlinearities, our design of ElastMan leverages the near-linear scalability of elastic Cloud services in order to build a scale-independent model of the service. Read more <a href="https://github.com/alshishtawy/ElastMan">here</a>.</p>

<br><br>

<a href="https://github.com/PonIC/PonIC"><img src="/images/projects/ponic.png" alt="PonIC" width="12%" height="12%"></a><br>
<p align="justify">PonIC is an initial implementation of an integration of Pig and Stratosphere. The current prototype supports a subset of the most common Pig operations and it can be easily extended to support the complete set of Pig Latin statements. Stratosphere has desirable properties that significantly simplify the plan generation. We argue that Pig can highly benefit from using Stratosphere as the back-end system and gain performance, without any loss of expressiveness. Read more <a href="https://github.com/PonIC/PonIC">here</a>.</p>

<br><br>

<a href="https://mozart.github.io"><img src="/images/projects/mozart.png" alt="Mozart" width="12%" height="12%"></a><br>
<p align="justify">The Mozart Programming System combines ongoing research in programming language design and implementation, constraint logic programming, distributed computing, and human-computer interfaces. Mozart implements the Oz language and provides both expressive power and advanced functionality. Read more <a href="https://mozart.github.io/">here</a>.</p>


